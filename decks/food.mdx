import { CodeSurfer as Surfer } from "code-surfer"; 
import { CodeSurferColumns, Step } from "code-surfer"; 
import { Appear, Background } from "gatsby-theme-mdx-deck"; 
import * as L from "../src/layout"; 
import customTheme from "../src/theme"; 
import GreetingLoader from "./src/greeting-loader";

export const theme = customTheme;

<L.Column>

Concurrent Mode
</L.Column>

<CodeSurferColumns sizes={[1, 2]}>

Disclaimer
Information in this talk may not be accurate or may change in the future
</L.Column>

<L.Row>

Time Slicing
"Chunking slow rendering on subtree into little blocks of work by interrupting the work loop."
</L.Row>

import DanDemoBlocking from '../assets/dan-demo-blocking.png';



import DanDemoConcurrent from '../assets/dan-demo-concurrent.png';



"Wait a minute... I already know about this! What is this talk really about?"
<L.Column>

Concurrent Mode
A chain of unfortunate consequences
</L.Column>

How does React "delay" rendering?
<L.Column>

Sources of Slowdown
Slow component render functions
Slow state setter or reducer updater functions
Slow effect functions
</L.Column>

import DeferredSetState from '../assets/deferred-setstate.svg';

<L.Row>

Deferred setState.
Any state setter or dispatch can be delayed.
</L.Row>

import InterruptRendering from '../assets/interrupt-rendering.svg';

<L.Row>

Interrupt Rendering.
Any rendering can be interrupted and can be completed later before committing.
</L.Row>

<L.Row>

Oops #1
Delaying rendering is only safe when no effects are pending on a subtree.
</L.Row>

import HooksAPI from '../assets/hooks-api.svg';

<L.Row>

The Hooks API.
This restriction is reflected in the hooks API with encapsulation of effects.
</L.Row>

import HooksAPITiming from '../assets/hooks-api-timing.svg';

<L.Row>

Hooks Timings.
With each hook we observe a part of the lifecycle and can react.
</L.Row>

import ComponentLifecycle from '../assets/component-lifecycle.svg';

<L.Row>

The Lifecycle.
The lifecycle we observe has three phases repeating.
</L.Row>

import ObservingLifecycleEvents from '../assets/observing-lifecycle-events.svg';

<L.Row>

Observing the Lifecycle.
Overlapping the lifecycle with hooks, we see a phase that we can't observe...
</L.Row>

import InterruptedLifecycle from '../assets/interrupted-lifecycle.svg';

<L.Row>

Interrupting the Lifecycle.
Unfortunately this phase becomes very relevant in Strict and Concurrent Mode.
</L.Row>

<L.Row>

Oops #2
It's not possible to have a subscription or effect track the component lifecycle.
</L.Row>

<L.Row>

Workaround
Resort to useSubscription
</L.Row>

import SchedulerPriorities from '../assets/scheduler-priorities.svg';

<L.Row>

Scheduler Priorities.
In Concurrent Mode the time budgets are switched on for time slicing.
</L.Row>

<L.Row>

Oops #3
Seems like React isn't all that predictable anymore.
</L.Row>

<L.Row>

Workaround
Synchronous Subscriber and scheduled teardown
</L.Row>

https://github.com/facebook/react/issues/15317#issuecomment-573337558

"We didn't yet get to what happens when an effect is slow, right?"
<L.Row>

Tearing
"When a subtree's renderered state falls behind while another subtree has committed updates already."
</L.Row>

import Tearing1 from '../assets/bvaughn-tearing-1.png'; import Tearing2 from '../assets/bvaughn-tearing-2.png';

<L.Row>   </L.Row>

<L.Column>

React's solution?
When an effect slows down, React can't safely interrupt or delay updates.
Instead it batches all updates and switches back to blocking mode
This is called a deopt.
</L.Column>

<L.Row>

Oops #4
React Concurrent's deopt can be slower than Blocking was before.
</L.Row>

<L.Column>

However
This may still cause tearing when another update is scheduled during this blocking batch.
</L.Column>

<L.Row>

Oops #5
A new useMutableSource hook is necessary to fix this tearing-during-deopt issue.
</L.Row>

<L.Column>

Concurrent Mode: Oops
</L.Column>